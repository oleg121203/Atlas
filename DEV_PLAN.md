# DEV\_PLAN.md

**UNIFIED INTERFACE**: PySide6 - єдиний UI фреймворк для всього додатку.

## Atlas Target Architecture

```
atlas/
├── main.py                 # Точка входу в додаток (PySide6)
├── core/                   # Основні компоненти системи
│   ├── application.py      # Головний клас AtlasApplication
│   ├── config.py           # Управління конфігурацією
│   ├── event_bus.py        # Система подій
│   ├── module_registry.py  # Реєстр модулів
│   ├── plugin_system.py    # Система плагінів
│   ├── self_healing.py     # Самовідновлення та авто-відновлення
│   └── agents/             # Система мета-агентів
├── ui/                     # UI компоненти на PySide6 (ЄДИНИЙ ІНТЕРФЕЙС)
│   ├── chat/               # Модуль чату
│   ├── tasks/              # Модуль завдань
│   ├── agents/             # Модуль агентів
│   ├── plugins/            # UI для управління плагінами
│   ├── settings/           # Інтерфейс налаштувань
│   ├── tools/              # UI для управління інструментами
│   ├── workflow/           # UI для робочих процесів
│   ├── memory/             # UI для управління пам'яттю
│   ├── self_improvement/   # Центр самовдосконалення
│   ├── themes/             # Система тем та їх перемикач
│   ├── developer/          # Інтеграція інструментів розробника
│   ├── context/            # UI для рушія контекстної обізнаності
│   └── stats/              # Статистика та аналітика
├── tools/                  # Екосистема інструментів
│   ├── base_tool.py        # Базовий клас інструменту
│   ├── browser.py          # Інструмент для браузера
│   ├── terminal_tool.py    # Інструмент для терміналу
│   ├── screenshot_tool.py  # Інструмент для скріншотів
│   └── {tool_name}.py      # Окремі інструменти
├── workflow/               # Система управління робочими процесами
│   ├── engine.py           # Рушій робочих процесів
│   ├── execution.py        # Виконання процесів
│   └── natural_language_workflow.py # Робочі процеси на природній мові
├── intelligence/           # ШІ та контекстна обізнаність
│   ├── context_awareness_engine.py # Розуміння контексту
│   └── llm.py              # Інтеграція з LLM
├── utils/                  # Основні утиліти
│   ├── memory_management.py # Система довгострокової пам'яті
│   ├── llm_manager.py      # Управління провайдерами LLM
│   └── cache_manager.py    # Оптимізація продуктивності
└── plugins/                # Екосистема плагінів (до створення)
    ├── base.py             # Абстрактний клас PluginBase
    └── {plugin_name}/      # Пакети окремих плагінів
```

-----

# Етап 2: Інтеграція систем та розширення функціональності

**Мета**: Перетворити програму зі стану "стабільного запуску" на "функціонально завершену". Це включає забезпечення безшовної та надійної взаємодії між інтегрованими системами, реалізацію ключового функціоналу та підготовку до тестування.

-----

## **Фаза 2.1: Налагодження міжмодульної взаємодії (EventBus)**

**Завдання**: Забезпечити, щоб усі частини програми коректно спілкувалися між собою, реагуючи на дії користувача та внутрішні системні події.

  * [x] **1. Стандартизація подій EventBus:**
      * **Завдання**: Створити централізований файл (наприклад, `core/events.py`), де будуть визначені та задокументовані всі типи подій (наприклад, `TaskCompleted`, `NewToolRegistered`, `ContextUpdated`, `ShowNotification`). Це створить єдине джерело правди для комунікацій.
  * [x] **2. Реалізація обробників критичних подій:**
      * **Завдання**: Імплементувати логіку в основних модулях (`chat`, `tasks`, `tools`) для обробки ключових подій. Наприклад, модуль `chat` має реагувати на подію `ContextUpdated` для оновлення свого стану, а `tasks` — на `TaskCompleted` для оновлення UI.
  * [x] **3. Повний перехід UI на подієву модель:**
      * **Завдання**: Провести рефакторинг UI-компонентів, щоб їхня логіка була повністю керована через `EventBus`. Усі дії користувача (натискання кнопок, вибір меню) мають генерувати події, а не викликати функції напряму, де це можливо.

-----

## **Фаза 2.2: Розширення та стабілізація ключових систем**

**Завдання**: Зробити базово інтегровані системи інтелекту, пам'яті та інструментів по-справжньому надійними та функціональними.

  * [x] **1. Інтелект та Пам'ять (Intelligence & Memory):**
      * **Завдання**: Додати обробку помилок для звернень до LLM API в `utils/llm_manager.py` (наприклад, таймаути, недоступність сервісу, невірний API-ключ).
      * [x] **Завдання**: Реалізувати механізм очищення та консолідації довгострокової пам'яті в `utils/memory_management.py` для уникнення її переповнення нерелевантними даними.
  * [x] **2. Екосистема інструментів (Tools Ecosystem):**
      * **Завдання**: Впровадити надійну обробку помилок під час виконання інструментів у `ToolManager`. UI має чітко показувати, коли інструмент виконав своє завдання успішно, а коли сталася помилка.
      * [x] **Завдання**: `ToolManagerUI` має динамічно оновлюватися при додаванні або видаленні інструментів без необхідності перезапуску програми.
  * [x] **3. Рушій робочих процесів (Workflow Engine):**
      * **Завдання**: Розширити логіку в `workflow/engine.py` для послідовного виконання завдань (ланцюжків інструментів) на основі визначеного плану. Це ядро автоматизації вашої програми.

-----

## **Фаза 2.3: Завершення UI та покращення досвіду користувача (UX)**

**Завдання**: "Оживити" інтерфейс, забезпечивши, щоб кожен його елемент був функціональним та відгукувався на дії користувача.

  * [ ] **1. Підключення всіх елементів управління:**
      * **Завдання**: Пройтися по всіх вікнах та панелях UI і переконатися, що кожна кнопка, меню та перемикач підключені до відповідної події `EventBus` або функції.
  * [x] **2. Впровадження зворотного зв'язку для користувача:**
      * **Завдання**: Додати індикатори завантаження (спіннери) для тривалих операцій (LLM, інструменти, workflow) у відповідних UI-модулях. Користувач повинен розуміти, що програма працює, а не зависла.
  * [x] **3. Фіналізація системи тем:**
      * **Завдання**: Перевірити, що система тем (`ui/themes`) коректно застосовується до всіх нових та існуючих компонентів UI, забезпечуючи візуальну цілісність.

-----

## **Фаза 2.4: Створення фундаменту для тестування**

**Завдання**: Започаткувати процес тестування для забезпечення стабільності програми в майбутньому та уникнення регресій.

  * [x] **1. Налаштування середовища для тестування:**
      * **Завдання**: Налаштувати `pytest` та додати плагін `pytest-qt` для тестування UI-компонентів. Створити базовий файл `tests/conftest.py` для загальних налаштувань.
  * [ ] **2. Написання перших Unit-тестів:**
      * **Завдання**: Написати набір тестів для критично важливих "чистих" функцій, наприклад, для валідаторів, функцій конфігурації в `core/config.py` та інших утиліт з папки `utils`.
  * [x] **3. Написання інтеграційного тесту для EventBus:**
      * **Завдання**: Створити простий тест, який перевіряє, що один модуль (наприклад, `MockModuleA`) може успішно відправити подію через `EventBus`, а інший (`MockModuleB`) її отримає. Це підтвердить, що основа для комунікації працює надійно.